{"version":3,"file":"typeSafety.js","sources":["../../src/core/typeSafety.ts"],"sourcesContent":["/**\n * 模板类型安全系统\n */\n\nimport type { ComputedRef, Ref} from 'vue';\nimport type { Template, TemplateEvents, TemplateProps } from '../types'\nimport { computed, ref } from 'vue'\n\n/**\n * 类型定义模板\n */\nexport interface TypedTemplate<\n  P extends Record<string, any> = TemplateProps,\n  E extends Record<string, any> = TemplateEvents,\n  S extends Record<string, any> = Record<string, any>\n> extends Template {\n  props?: P\n  events?: E\n  slots?: S\n}\n\n/**\n * 严格类型的模板属性\n */\nexport interface StrictTemplateProps {\n  [key: string]: {\n    type: PropType<any>\n    required?: boolean\n    default?: any\n    validator?: (value: any) => boolean\n  }\n}\n\n/**\n * 属性类型\n */\nexport type PropType<T> = \n  | StringConstructor\n  | NumberConstructor\n  | BooleanConstructor\n  | ArrayConstructor\n  | ObjectConstructor\n  | DateConstructor\n  | FunctionConstructor\n  | SymbolConstructor\n  | { new(...args: any[]): T }\n  | T[]\n\n/**\n * 推断属性类型\n */\nexport type InferPropType<T> = T extends PropType<infer U> ? U : any\n\n/**\n * 推断模板属性类型\n */\nexport type InferTemplateProps<T extends StrictTemplateProps> = {\n  [K in keyof T]: InferPropType<T[K]['type']>\n}\n\n/**\n * 类型验证器\n */\nexport class TypeValidator {\n  private validators: Map<string, (value: any) => boolean> = new Map()\n  \n  /**\n   * 注册验证器\n   */\n  register(type: string, validator: (value: any) => boolean) {\n    this.validators.set(type, validator)\n  }\n  \n  /**\n   * 验证值\n   */\n  validate(value: any, type: string | PropType<any>): boolean {\n    if (typeof type === 'string') {\n      const validator = this.validators.get(type)\n      return validator ? validator(value) : true\n    }\n    \n    if (Array.isArray(type)) {\n      return type.some(t => this.validateConstructor(value, t))\n    }\n    \n    return this.validateConstructor(value, type as any)\n  }\n  \n  /**\n   * 验证构造函数类型\n   */\n  private validateConstructor(value: any, constructor: any): boolean {\n    if (constructor === String) return typeof value === 'string'\n    if (constructor === Number) return typeof value === 'number'\n    if (constructor === Boolean) return typeof value === 'boolean'\n    if (constructor === Array) return Array.isArray(value)\n    if (constructor === Object) return typeof value === 'object' && value !== null\n    if (constructor === Date) return value instanceof Date\n    if (constructor === Function) return typeof value === 'function'\n    if (constructor === Symbol) return typeof value === 'symbol'\n    \n    return value instanceof constructor\n  }\n}\n\n/**\n * 类型生成器\n */\nexport class TypeGenerator {\n  /**\n   * 从模板生成类型定义\n   */\n  generateFromTemplate(template: Template): string {\n    const lines: string[] = []\n    \n    // 生成接口名称\n    const interfaceName = `${this.toPascalCase(template.name)}Template`\n    \n    lines.push(`export interface ${interfaceName} {`)\n    \n    // 生成属性类型\n    if ((template as any).props) {\n      lines.push('  props: {')\n      for (const [key, prop] of Object.entries((template as any).props)) {\n        const type = this.inferType(prop)\n        lines.push(`    ${key}: ${type};`)\n      }\n      lines.push('  };')\n    }\n    \n    // 生成事件类型\n    if ((template as any).events) {\n      lines.push('  events: {')\n      for (const [key, event] of Object.entries((template as any).events)) {\n        const type = this.inferEventType(event)\n        lines.push(`    ${key}: ${type};`)\n      }\n      lines.push('  };')\n    }\n    \n    // 生成插槽类型\n    if ((template as any).slots) {\n      lines.push('  slots: {')\n      for (const key of Object.keys((template as any).slots)) {\n        lines.push(`    ${key}: any;`)\n      }\n      lines.push('  };')\n    }\n    \n    lines.push('}')\n    \n    return lines.join('\\n')\n  }\n  \n  /**\n   * 批量生成类型定义\n   */\n  generateTypes(templates: Template[]): string {\n    const types = templates.map(t => this.generateFromTemplate(t))\n    \n    // 添加导入语句\n    const imports = [\n      \"import type { Template } from './types'\",\n      ''\n    ]\n    \n    // 添加索引类型\n    const indexType = [\n      '',\n      'export interface TemplateMap {',\n      ...templates.map(t => `  '${t.name}': ${this.toPascalCase(t.name)}Template;`),\n      '}'\n    ]\n    \n    return [...imports, ...types, ...indexType].join('\\n')\n  }\n  \n  /**\n   * 推断类型\n   */\n  private inferType(value: any): string {\n    if (value === null) return 'null'\n    if (value === undefined) return 'undefined'\n    \n    const type = typeof value\n    \n    switch (type) {\n      case 'string':\n        return 'string'\n      case 'number':\n        return 'number'\n      case 'boolean':\n        return 'boolean'\n      case 'function':\n        return this.inferFunctionType(value)\n      case 'object':\n        if (Array.isArray(value)) {\n          return this.inferArrayType(value)\n        }\n        return this.inferObjectType(value)\n      default:\n        return 'any'\n    }\n  }\n  \n  /**\n   * 推断函数类型\n   */\n  private inferFunctionType(fn: (...args: any[]) => any): string {\n    const params = fn.length\n    const paramTypes = Array.from({ length: params }, () => 'any').join(', ')\n    return `(${paramTypes}) => any`\n  }\n  \n  /**\n   * 推断数组类型\n   */\n  private inferArrayType(arr: any[]): string {\n    if (arr.length === 0) return 'any[]'\n    \n    const types = new Set(arr.map(item => this.inferType(item)))\n    \n    if (types.size === 1) {\n      return `${Array.from(types)[0]}[]`\n    }\n    \n    return `(${Array.from(types).join(' | ')})[]`\n  }\n  \n  /**\n   * 推断对象类型\n   */\n  private inferObjectType(obj: Record<string, any>): string {\n    const props = Object.entries(obj)\n      .map(([key, value]) => `${key}: ${this.inferType(value)}`)\n      .join('; ')\n    \n    return `{ ${props} }`\n  }\n  \n  /**\n   * 推断事件类型\n   */\n  private inferEventType(event: any): string {\n    if (typeof event === 'function') {\n      return this.inferFunctionType(event)\n    }\n    return '(...args: any[]) => void'\n  }\n  \n  /**\n   * 转换为帕斯卡命名\n   */\n  private toPascalCase(str: string): string {\n    return str\n      .replace(/[-_](\\w)/g, (_, c) => c.toUpperCase())\n      .replace(/^\\w/, c => c.toUpperCase())\n  }\n}\n\n/**\n * 类型守卫\n */\nexport class TypeGuard {\n  /**\n   * 是否为特定模板类型\n   */\n  static isTemplate<T extends Template>(\n    template: any,\n    type: { new(...args: any[]): T }\n  ): template is T {\n    return template instanceof type\n  }\n  \n  /**\n   * 是否有必需属性\n   */\n  static hasRequiredProps<T extends Record<string, any>>(\n    obj: any,\n    props: (keyof T)[]\n  ): obj is T {\n    return props.every(prop => prop in obj)\n  }\n  \n  /**\n   * 是否为有效的模板属性\n   */\n  static isValidTemplateProps<T extends TemplateProps>(\n    props: any,\n    schema: StrictTemplateProps\n  ): props is T {\n    const validator = new TypeValidator()\n    \n    for (const [key, config] of Object.entries(schema)) {\n      if (config.required && !(key in props)) {\n        return false\n      }\n      \n      if (key in props) {\n        const value = props[key]\n        \n        if (!validator.validate(value, config.type)) {\n          return false\n        }\n        \n        if (config.validator && !config.validator(value)) {\n          return false\n        }\n      }\n    }\n    \n    return true\n  }\n}\n\n/**\n * 创建类型安全的模板\n */\nexport function createTypedTemplate<\n  P extends StrictTemplateProps,\n  E extends Record<string, (...args: any[]) => void> = Record<string, never>,\n  S extends Record<string, any> = Record<string, never>\n>(config: {\n  name: string\n  props?: P\n  events?: E\n  slots?: S\n  setup?: (props: InferTemplateProps<P>) => any\n  render?: (ctx: any) => any\n}): TypedTemplate<InferTemplateProps<P>, E, S> {\n  const template: TypedTemplate<InferTemplateProps<P>, E, S> = {\n    id: `typed-${config.name}`,\n    name: config.name,\n    category: 'typed',\n    props: config.props as any,\n    events: config.events,\n    slots: config.slots\n  } as any\n  \n  // 添加类型验证\n  if (config.setup) {\n    const originalSetup = config.setup\n    ;(template as any).setup = (props: any) => {\n      // 运行时类型检查\n      if (config.props && !TypeGuard.isValidTemplateProps(props, config.props)) {\n        console.error(`Invalid props for template ${config.name}`)\n      }\n      \n      return originalSetup(props as InferTemplateProps<P>)\n    }\n  }\n  \n  return template\n}\n\n/**\n * 使用类型安全的模板\n */\nexport function useTypedTemplate<T extends TypedTemplate>(\n  template: T | Ref<T>\n): {\n  template: ComputedRef<T>\n  props: ComputedRef<T['props']>\n  events: ComputedRef<T['events']>\n  slots: ComputedRef<T['slots']>\n  validate: (props: any) => boolean\n} {\n  const templateRef = ref(template) as Ref<T>\n  \n  const computedTemplate = computed<T>(() => \n    'value' in templateRef.value ? (templateRef.value as any).value : templateRef.value\n  )\n  \n  const props = computed(() => (computedTemplate.value as any).props)\n  const events = computed(() => (computedTemplate.value as any).events)\n  const slots = computed(() => (computedTemplate.value as any).slots)\n  \n  const validate = (inputProps: any): boolean => {\n    const schema = (computedTemplate.value as any).props\n    if (!schema) return true\n    \n    return TypeGuard.isValidTemplateProps(inputProps, schema as any)\n  }\n  \n  return {\n    template: computedTemplate as any,\n    props,\n    events,\n    slots,\n    validate\n  }\n}\n\n/**\n * 类型映射工具\n */\nexport class TypeMapper {\n  private mappings: Map<string, string> = new Map([\n    ['String', 'string'],\n    ['Number', 'number'],\n    ['Boolean', 'boolean'],\n    ['Array', 'any[]'],\n    ['Object', 'Record<string, any>'],\n    ['Date', 'Date'],\n    ['Function', 'Function'],\n    ['Symbol', 'symbol']\n  ])\n  \n  /**\n   * 添加自定义映射\n   */\n  addMapping(from: string, to: string) {\n    this.mappings.set(from, to)\n  }\n  \n  /**\n   * 映射类型\n   */\n  map(type: string): string {\n    return this.mappings.get(type) || 'any'\n  }\n  \n  /**\n   * 批量映射\n   */\n  mapBatch(types: Record<string, string>): Record<string, string> {\n    const result: Record<string, string> = {}\n    \n    for (const [key, value] of Object.entries(types)) {\n      result[key] = this.map(value)\n    }\n    \n    return result\n  }\n}\n\n/**\n * 模板类型注册表\n */\nexport class TemplateTypeRegistry {\n  private static instance: TemplateTypeRegistry\n  private registry: Map<string, TypedTemplate> = new Map()\n  private schemas: Map<string, StrictTemplateProps> = new Map()\n  \n  private constructor() {}\n  \n  static getInstance(): TemplateTypeRegistry {\n    if (!this.instance) {\n      this.instance = new TemplateTypeRegistry()\n    }\n    return this.instance\n  }\n  \n  /**\n   * 注册模板类型\n   */\n  register<T extends TypedTemplate>(template: T, schema?: StrictTemplateProps) {\n    this.registry.set(template.name, template)\n    \n    if (schema) {\n      this.schemas.set(template.name, schema)\n    }\n  }\n  \n  /**\n   * 获取模板类型\n   */\n  get<T extends TypedTemplate>(name: string): T | undefined {\n    return this.registry.get(name) as T\n  }\n  \n  /**\n   * 获取模板schema\n   */\n  getSchema(name: string): StrictTemplateProps | undefined {\n    return this.schemas.get(name)\n  }\n  \n  /**\n   * 获取所有模板类型\n   */\n  getAll(): TypedTemplate[] {\n    return Array.from(this.registry.values())\n  }\n  \n  /**\n   * 生成类型定义文件\n   */\n  generateTypeDefinitions(): string {\n    const generator = new TypeGenerator()\n    const templates = this.getAll()\n    return generator.generateTypes(templates as Template[])\n  }\n}\n\n// 导出单例\nexport const typeValidator = new TypeValidator()\nexport const typeGenerator = new TypeGenerator()\nexport const typeMapper = new TypeMapper()\nexport const typeRegistry = TemplateTypeRegistry.getInstance()"],"names":["TypeValidator","constructor","validators","Map","register","type","validator","set","validate","value","get","Array","isArray","some","t","validateConstructor","String","Number","Boolean","Object","Date","Function","Symbol","TypeGenerator","generateFromTemplate","template","lines","interfaceName","toPascalCase","name","push","props","key","prop","entries","inferType","events","event","inferEventType","slots","keys","join","generateTypes","templates","types","map","imports","indexType","undefined","inferFunctionType","inferArrayType","inferObjectType","fn","params","length","paramTypes","from","arr","Set","item","size","obj","str","replace","_","c","toUpperCase","TypeGuard","isTemplate","hasRequiredProps","every","isValidTemplateProps","schema","config","required","createTypedTemplate","id","category","setup","originalSetup","console","error","useTypedTemplate","templateRef","ref","computedTemplate","computed","inputProps","TypeMapper","mappings","addMapping","to","mapBatch","result","TemplateTypeRegistry","registry","schemas","getInstance","instance","getSchema","getAll","values","generateTypeDefinitions","generator","typeValidator","typeGenerator","typeMapper","typeRegistry"],"mappings":";;;;;;;;;;;MA+DaA,aAAAA,CAAa;AAAA,EAA1BC,WAAAA,GAAA;AACU,IAAA,IAAA,CAAAC,UAAAA,uBAAuDC,GAAAA,EAAG;AAAA,EAwCpE;AAAA;AAAA;AAAA;AAAA,EAnCEC,QAAAA,CAASC,MAAcC,SAAAA,EAAkC;AACvD,IAAA,IAAA,CAAKJ,UAAAA,CAAWK,GAAAA,CAAIF,IAAAA,EAAMC,SAAS,CAAA;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKAE,QAAAA,CAASC,OAAYJ,IAAAA,EAA4B;AAC/C,IAAA,IAAI,OAAOA,SAAS,QAAA,EAAU;AAC5B,MAAA,MAAMC,SAAAA,GAAY,IAAA,CAAKJ,UAAAA,CAAWQ,GAAAA,CAAIL,IAAI,CAAA;AAC1C,MAAA,OAAOC,SAAAA,GAAYA,SAAAA,CAAUG,KAAK,CAAA,GAAI,IAAA;AAAA,IACxC;AAEA,IAAA,IAAIE,KAAAA,CAAMC,OAAAA,CAAQP,IAAI,CAAA,EAAG;AACvB,MAAA,OAAOA,KAAKQ,IAAAA,CAAKC,CAAAA,CAAAA,KAAK,KAAKC,mBAAAA,CAAoBN,KAAAA,EAAOK,CAAC,CAAC,CAAA;AAAA,IAC1D;AAEA,IAAA,OAAO,IAAA,CAAKC,mBAAAA,CAAoBN,KAAAA,EAAOJ,IAAW,CAAA;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA,EAKQU,mBAAAA,CAAoBN,OAAYR,WAAAA,EAAgB;AACtD,IAAA,IAAIA,WAAAA,KAAgBe,MAAAA,EAAQ,OAAO,OAAOP,KAAAA,KAAU,QAAA;AACpD,IAAA,IAAIR,WAAAA,KAAgBgB,MAAAA,EAAQ,OAAO,OAAOR,KAAAA,KAAU,QAAA;AACpD,IAAA,IAAIR,WAAAA,KAAgBiB,OAAAA,EAAS,OAAO,OAAOT,KAAAA,KAAU,SAAA;AACrD,IAAA,IAAIR,WAAAA,KAAgBU,KAAAA,EAAO,OAAOA,KAAAA,CAAMC,QAAQH,KAAK,CAAA;AACrD,IAAA,IAAIR,gBAAgBkB,MAAAA,EAAQ,OAAO,OAAOV,KAAAA,KAAU,YAAYA,KAAAA,KAAU,IAAA;AAC1E,IAAA,IAAIR,WAAAA,KAAgBmB,IAAAA,EAAM,OAAOX,KAAAA,YAAiBW,IAAAA;AAClD,IAAA,IAAInB,WAAAA,KAAgBoB,QAAAA,EAAU,OAAO,OAAOZ,KAAAA,KAAU,UAAA;AACtD,IAAA,IAAIR,WAAAA,KAAgBqB,MAAAA,EAAQ,OAAO,OAAOb,KAAAA,KAAU,QAAA;AAEpD,IAAA,OAAOA,KAAAA,YAAiBR,WAAAA;AAAAA,EAC1B;AACD;MAKYsB,aAAAA,CAAa;AAAA;AAAA;AAAA;AAAA,EAIxBC,qBAAqBC,QAAAA,EAAkB;AACrC,IAAA,MAAMC,QAAkB,EAAA;AAGxB,IAAA,MAAMC,gBAAgB,CAAA,EAAG,IAAA,CAAKC,YAAAA,CAAaH,QAAAA,CAASI,IAAI,CAAC,CAAA,QAAA,CAAA;AAEzDH,IAAAA,KAAAA,CAAMI,IAAAA,CAAK,CAAA,iBAAA,EAAoBH,aAAa,CAAA,EAAA,CAAI,CAAA;AAGhD,IAAA,IAAKF,SAAiBM,KAAAA,EAAO;AAC3BL,MAAAA,KAAAA,CAAMI,KAAK,YAAY,CAAA;AACvB,MAAA,KAAA,MAAW,CAACE,KAAKC,IAAI,CAAA,IAAKd,OAAOe,OAAAA,CAAST,QAAAA,CAAiBM,KAAK,CAAA,EAAG;AACjE,QAAA,MAAM1B,IAAAA,GAAO,IAAA,CAAK8B,SAAAA,CAAUF,IAAI,CAAA;AAChCP,QAAAA,KAAAA,CAAMI,IAAAA,CAAK,CAAA,IAAA,EAAOE,GAAG,CAAA,EAAA,EAAK3B,IAAI,CAAA,CAAA,CAAG,CAAA;AAAA,MACnC;AACAqB,MAAAA,KAAAA,CAAMI,KAAK,MAAM,CAAA;AAAA,IACnB;AAGA,IAAA,IAAKL,SAAiBW,MAAAA,EAAQ;AAC5BV,MAAAA,KAAAA,CAAMI,KAAK,aAAa,CAAA;AACxB,MAAA,KAAA,MAAW,CAACE,KAAKK,KAAK,CAAA,IAAKlB,OAAOe,OAAAA,CAAST,QAAAA,CAAiBW,MAAM,CAAA,EAAG;AACnE,QAAA,MAAM/B,IAAAA,GAAO,IAAA,CAAKiC,cAAAA,CAAeD,KAAK,CAAA;AACtCX,QAAAA,KAAAA,CAAMI,IAAAA,CAAK,CAAA,IAAA,EAAOE,GAAG,CAAA,EAAA,EAAK3B,IAAI,CAAA,CAAA,CAAG,CAAA;AAAA,MACnC;AACAqB,MAAAA,KAAAA,CAAMI,KAAK,MAAM,CAAA;AAAA,IACnB;AAGA,IAAA,IAAKL,SAAiBc,KAAAA,EAAO;AAC3Bb,MAAAA,KAAAA,CAAMI,KAAK,YAAY,CAAA;AACvB,MAAA,KAAA,MAAWE,GAAAA,IAAOb,MAAAA,CAAOqB,IAAAA,CAAMf,QAAAA,CAAiBc,KAAK,CAAA,EAAG;AACtDb,QAAAA,KAAAA,CAAMI,IAAAA,CAAK,CAAA,IAAA,EAAOE,GAAG,CAAA,MAAA,CAAQ,CAAA;AAAA,MAC/B;AACAN,MAAAA,KAAAA,CAAMI,KAAK,MAAM,CAAA;AAAA,IACnB;AAEAJ,IAAAA,KAAAA,CAAMI,KAAK,GAAG,CAAA;AAEd,IAAA,OAAOJ,KAAAA,CAAMe,KAAK,IAAI,CAAA;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKAC,cAAcC,SAAAA,EAAqB;AACjC,IAAA,MAAMC,QAAQD,SAAAA,CAAUE,GAAAA,CAAI/B,OAAK,IAAA,CAAKU,oBAAAA,CAAqBV,CAAC,CAAC,CAAA;AAG7D,IAAA,MAAMgC,OAAAA,GAAU,CACd,yCAAA,EACA,EAAE,CAAA;AAIJ,IAAA,MAAMC,YAAY,CAChB,EAAA,EACA,kCACA,GAAGJ,SAAAA,CAAUE,IAAI/B,CAAAA,CAAAA,KAAK,CAAA,GAAA,EAAMA,EAAEe,IAAI,CAAA,GAAA,EAAM,KAAKD,YAAAA,CAAad,CAAAA,CAAEe,IAAI,CAAC,CAAA,SAAA,CAAW,GAC5E,GAAG,CAAA;AAGL,IAAA,OAAO,CAAC,GAAGiB,OAAAA,EAAS,GAAGF,OAAO,GAAGG,SAAS,CAAA,CAAEN,IAAAA,CAAK,IAAI,CAAA;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAKQN,UAAU1B,KAAAA,EAAU;AAC1B,IAAA,IAAIA,KAAAA,KAAU,MAAM,OAAO,MAAA;AAC3B,IAAA,IAAIA,KAAAA,KAAUuC,QAAW,OAAO,WAAA;AAEhC,IAAA,MAAM3C,OAAO,OAAOI,KAAAA;AAEpB,IAAA,QAAQJ,IAAAA;AAAI,MACV,KAAK,QAAA;AACH,QAAA,OAAO,QAAA;AAAA,MACT,KAAK,QAAA;AACH,QAAA,OAAO,QAAA;AAAA,MACT,KAAK,SAAA;AACH,QAAA,OAAO,SAAA;AAAA,MACT,KAAK,UAAA;AACH,QAAA,OAAO,IAAA,CAAK4C,kBAAkBxC,KAAK,CAAA;AAAA,MACrC,KAAK,QAAA;AACH,QAAA,IAAIE,KAAAA,CAAMC,OAAAA,CAAQH,KAAK,CAAA,EAAG;AACxB,UAAA,OAAO,IAAA,CAAKyC,eAAezC,KAAK,CAAA;AAAA,QAClC;AACA,QAAA,OAAO,IAAA,CAAK0C,gBAAgB1C,KAAK,CAAA;AAAA,MACnC;AACE,QAAA,OAAO,KAAA;AAAA;AACX,EACF;AAAA;AAAA;AAAA;AAAA,EAKQwC,kBAAkBG,EAAAA,EAA2B;AACnD,IAAA,MAAMC,SAASD,EAAAA,CAAGE,MAAAA;AAClB,IAAA,MAAMC,UAAAA,GAAa5C,MAAM6C,IAAAA,CAAK;AAAA,MAAEF,MAAAA,EAAQD;AAAAA,KAAM,EAAI,MAAM,KAAK,CAAA,CAAEZ,KAAK,IAAI,CAAA;AACxE,IAAA,OAAO,IAAIc,UAAU,CAAA,QAAA,CAAA;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAKQL,eAAeO,GAAAA,EAAU;AAC/B,IAAA,IAAIA,GAAAA,CAAIH,MAAAA,KAAW,CAAA,EAAG,OAAO,OAAA;AAE7B,IAAA,MAAMV,KAAAA,GAAQ,IAAIc,GAAAA,CAAID,GAAAA,CAAIZ,GAAAA,CAAIc,UAAQ,IAAA,CAAKxB,SAAAA,CAAUwB,IAAI,CAAC,CAAC,CAAA;AAE3D,IAAA,IAAIf,KAAAA,CAAMgB,SAAS,CAAA,EAAG;AACpB,MAAA,OAAO,GAAGjD,KAAAA,CAAM6C,IAAAA,CAAKZ,KAAK,CAAA,CAAE,CAAC,CAAC,CAAA,EAAA,CAAA;AAAA,IAChC;AAEA,IAAA,OAAO,IAAIjC,KAAAA,CAAM6C,IAAAA,CAAKZ,KAAK,CAAA,CAAEH,IAAAA,CAAK,KAAK,CAAC,CAAA,GAAA,CAAA;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKQU,gBAAgBU,GAAAA,EAAwB;AAC9C,IAAA,MAAM9B,KAAAA,GAAQZ,OAAOe,OAAAA,CAAQ2B,GAAG,EAC7BhB,GAAAA,CAAI,CAAC,CAACb,GAAAA,EAAKvB,KAAK,MAAM,CAAA,EAAGuB,GAAG,KAAK,IAAA,CAAKG,SAAAA,CAAU1B,KAAK,CAAC,CAAA,CAAE,CAAA,CACxDgC,IAAAA,CAAK,IAAI,CAAA;AAEZ,IAAA,OAAO,KAAKV,KAAK,CAAA,EAAA,CAAA;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKQO,eAAeD,KAAAA,EAAU;AAC/B,IAAA,IAAI,OAAOA,UAAU,UAAA,EAAY;AAC/B,MAAA,OAAO,IAAA,CAAKY,kBAAkBZ,KAAK,CAAA;AAAA,IACrC;AACA,IAAA,OAAO,0BAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQT,aAAakC,GAAAA,EAAW;AAC9B,IAAA,OAAOA,GAAAA,CACJC,OAAAA,CAAQ,WAAA,EAAa,CAACC,GAAGC,CAAAA,KAAMA,CAAAA,CAAEC,WAAAA,EAAa,EAC9CH,OAAAA,CAAQ,KAAA,EAAOE,CAAAA,CAAAA,KAAKA,CAAAA,CAAEC,aAAa,CAAA;AAAA,EACxC;AACD;MAKYC,SAAAA,CAAS;AAAA;AAAA;AAAA;AAAA,EAIpB,OAAOC,UAAAA,CACL3C,QAAAA,EACApB,IAAAA,EAAgC;AAEhC,IAAA,OAAOoB,QAAAA,YAAoBpB,IAAAA;AAAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAKA,OAAOgE,gBAAAA,CACLR,GAAAA,EACA9B,KAAAA,EAAkB;AAElB,IAAA,OAAOA,KAAAA,CAAMuC,KAAAA,CAAMrC,CAAAA,IAAAA,KAAQA,IAAAA,IAAQ4B,GAAG,CAAA;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKA,OAAOU,oBAAAA,CACLxC,KAAAA,EACAyC,MAAAA,EAA2B;AAE3B,IAAA,MAAMlE,SAAAA,GAAY,IAAIN,aAAAA;AAEtB,IAAA,KAAA,MAAW,CAACgC,GAAAA,EAAKyC,MAAM,KAAKtD,MAAAA,CAAOe,OAAAA,CAAQsC,MAAM,CAAA,EAAG;AAClD,MAAA,IAAIC,MAAAA,CAAOC,QAAAA,IAAY,EAAE1C,GAAAA,IAAOD,KAAAA,CAAAA,EAAQ;AACtC,QAAA,OAAO,KAAA;AAAA,MACT;AAEA,MAAA,IAAIC,OAAOD,KAAAA,EAAO;AAChB,QAAA,MAAMtB,KAAAA,GAAQsB,MAAMC,GAAG,CAAA;AAEvB,QAAA,IAAI,CAAC1B,SAAAA,CAAUE,QAAAA,CAASC,KAAAA,EAAOgE,MAAAA,CAAOpE,IAAI,CAAA,EAAG;AAC3C,UAAA,OAAO,KAAA;AAAA,QACT;AAEA,QAAA,IAAIoE,OAAOnE,SAAAA,IAAa,CAACmE,MAAAA,CAAOnE,SAAAA,CAAUG,KAAK,CAAA,EAAG;AAChD,UAAA,OAAO,KAAA;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAEA,IAAA,OAAO,IAAA;AAAA,EACT;AACD;AAKK,SAAUkE,oBAIdF,MAAAA,EAOD;AACC,EAAA,MAAMhD,QAAAA,GAAuD;AAAA,IAC3DmD,EAAAA,EAAI,CAAA,MAAA,EAASH,MAAAA,CAAO5C,IAAI,CAAA,CAAA;AAAA,IACxBA,MAAM4C,MAAAA,CAAO5C,IAAAA;AAAAA,IACbgD,QAAAA,EAAU,OAAA;AAAA,IACV9C,OAAO0C,MAAAA,CAAO1C,KAAAA;AAAAA,IACdK,QAAQqC,MAAAA,CAAOrC,MAAAA;AAAAA,IACfG,OAAOkC,MAAAA,CAAOlC;AAAAA;AAIhB,EAAA,IAAIkC,OAAOK,KAAAA,EAAO;AAChB,IAAA,MAAMC,gBAAgBN,MAAAA,CAAOK,KAAAA;AAC3BrD,IAAAA,QAAAA,CAAiBqD,QAAS/C,CAAAA,KAAAA,KAAc;AAExC,MAAA,IAAI0C,MAAAA,CAAO1C,SAAS,CAACoC,SAAAA,CAAUI,qBAAqBxC,KAAAA,EAAO0C,MAAAA,CAAO1C,KAAK,CAAA,EAAG;AACxEiD,QAAAA,OAAAA,CAAQC,KAAAA,CAAM,CAAA,2BAAA,EAA8BR,MAAAA,CAAO5C,IAAI,CAAA,CAAE,CAAA;AAAA,MAC3D;AAEA,MAAA,OAAOkD,cAAchD,KAA8B,CAAA;AAAA,IACrD,CAAA;AAAA,EACF;AAEA,EAAA,OAAON,QAAAA;AACT;AAKM,SAAUyD,iBACdzD,QAAAA,EAAoB;AAQpB,EAAA,MAAM0D,WAAAA,GAAcC,IAAI3D,QAAQ,CAAA;AAEhC,EAAA,MAAM4D,gBAAAA,GAAmBC,QAAAA,CAAY,MACnC,OAAA,IAAWH,WAAAA,CAAY1E,QAAS0E,WAAAA,CAAY1E,KAAAA,CAAcA,KAAAA,GAAQ0E,WAAAA,CAAY1E,KAAK,CAAA;AAGrF,EAAA,MAAMsB,KAAAA,GAAQuD,QAAAA,CAAS,MAAOD,gBAAAA,CAAiB5E,MAAcsB,KAAK,CAAA;AAClE,EAAA,MAAMK,MAAAA,GAASkD,QAAAA,CAAS,MAAOD,gBAAAA,CAAiB5E,MAAc2B,MAAM,CAAA;AACpE,EAAA,MAAMG,KAAAA,GAAQ+C,QAAAA,CAAS,MAAOD,gBAAAA,CAAiB5E,MAAc8B,KAAK,CAAA;AAElE,EAAA,MAAM/B,WAAY+E,CAAAA,UAAAA,KAA4B;AAC5C,IAAA,MAAMf,MAAAA,GAAUa,iBAAiB5E,KAAAA,CAAcsB,KAAAA;AAC/C,IAAA,IAAI,CAACyC,QAAQ,OAAO,IAAA;AAEpB,IAAA,OAAOL,SAAAA,CAAUI,oBAAAA,CAAqBgB,UAAAA,EAAYf,MAAa,CAAA;AAAA,EACjE,CAAA;AAEA,EAAA,OAAO;AAAA,IACL/C,QAAAA,EAAU4D,gBAAAA;AAAAA,IACVtD,KAAAA;AAAAA,IACAK,MAAAA;AAAAA,IACAG,KAAAA;AAAAA,IACA/B;AAAAA;AAEJ;MAKagF,UAAAA,CAAU;AAAA,EAAvBvF,WAAAA,GAAA;AACU,IAAA,IAAA,CAAAwF,2BAAgC,IAAItF,GAAAA,CAAI,CAC9C,CAAC,UAAU,QAAQ,CAAA,EACnB,CAAC,QAAA,EAAU,QAAQ,CAAA,EACnB,CAAC,SAAA,EAAW,SAAS,GACrB,CAAC,OAAA,EAAS,OAAO,CAAA,EACjB,CAAC,QAAA,EAAU,qBAAqB,CAAA,EAChC,CAAC,QAAQ,MAAM,CAAA,EACf,CAAC,UAAA,EAAY,UAAU,CAAA,EACvB,CAAC,QAAA,EAAU,QAAQ,CAAC,CACrB,CAAA;AAAA,EA4BH;AAAA;AAAA;AAAA;AAAA,EAvBEuF,UAAAA,CAAWlC,MAAcmC,EAAAA,EAAU;AACjC,IAAA,IAAA,CAAKF,QAAAA,CAASlF,GAAAA,CAAIiD,IAAAA,EAAMmC,EAAE,CAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKA9C,IAAIxC,IAAAA,EAAY;AACd,IAAA,OAAO,IAAA,CAAKoF,QAAAA,CAAS/E,GAAAA,CAAIL,IAAI,CAAA,IAAK,KAAA;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKAuF,SAAShD,KAAAA,EAA6B;AACpC,IAAA,MAAMiD,SAAiC,EAAA;AAEvC,IAAA,KAAA,MAAW,CAAC7D,GAAAA,EAAKvB,KAAK,KAAKU,MAAAA,CAAOe,OAAAA,CAAQU,KAAK,CAAA,EAAG;AAChDiD,MAAAA,MAAAA,CAAO7D,GAAG,CAAA,GAAI,IAAA,CAAKa,GAAAA,CAAIpC,KAAK,CAAA;AAAA,IAC9B;AAEA,IAAA,OAAOoF,MAAAA;AAAAA,EACT;AACD;MAKYC,oBAAAA,CAAoB;AAAA,EAK/B7F,WAAAA,GAAA;AAHQ,IAAA,IAAA,CAAA8F,QAAAA,uBAA2C5F,GAAAA,EAAG;AAC9C,IAAA,IAAA,CAAA6F,OAAAA,uBAAgD7F,GAAAA,EAAG;AAAA,EAEpC;AAAA,EAEvB,OAAO8F,WAAAA,GAAW;AAChB,IAAA,IAAI,CAAC,KAAKC,QAAAA,EAAU;AAClB,MAAA,IAAA,CAAKA,QAAAA,GAAW,IAAIJ,oBAAAA;IACtB;AACA,IAAA,OAAO,IAAA,CAAKI,QAAAA;AAAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA9F,QAAAA,CAAkCqB,UAAa+C,MAAAA,EAA4B;AACzE,IAAA,IAAA,CAAKuB,QAAAA,CAASxF,GAAAA,CAAIkB,QAAAA,CAASI,IAAAA,EAAMJ,QAAQ,CAAA;AAEzC,IAAA,IAAI+C,MAAAA,EAAQ;AACV,MAAA,IAAA,CAAKwB,OAAAA,CAAQzF,GAAAA,CAAIkB,QAAAA,CAASI,IAAAA,EAAM2C,MAAM,CAAA;AAAA,IACxC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA9D,IAA6BmB,IAAAA,EAAY;AACvC,IAAA,OAAO,IAAA,CAAKkE,QAAAA,CAASrF,GAAAA,CAAImB,IAAI,CAAA;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAKAsE,UAAUtE,IAAAA,EAAY;AACpB,IAAA,OAAO,IAAA,CAAKmE,OAAAA,CAAQtF,GAAAA,CAAImB,IAAI,CAAA;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAKAuE,MAAAA,GAAM;AACJ,IAAA,OAAOzF,KAAAA,CAAM6C,IAAAA,CAAK,IAAA,CAAKuC,QAAAA,CAASM,QAAQ,CAAA;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKAC,uBAAAA,GAAuB;AACrB,IAAA,MAAMC,SAAAA,GAAY,IAAIhF,aAAAA;AACtB,IAAA,MAAMoB,SAAAA,GAAY,KAAKyD,MAAAA;AACvB,IAAA,OAAOG,SAAAA,CAAU7D,cAAcC,SAAuB,CAAA;AAAA,EACxD;AACD;AAGM,MAAM6D,aAAAA,GAAgB,IAAIxG,aAAAA;AAC1B,MAAMyG,aAAAA,GAAgB,IAAIlF,aAAAA;AAC1B,MAAMmF,UAAAA,GAAa,IAAIlB,UAAAA;AACvB,MAAMmB,YAAAA,GAAeb,qBAAqBG,WAAAA;;;;;;;"}