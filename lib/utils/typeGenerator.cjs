/*!
 * ***********************************
 * @ldesign/template v0.1.0        *
 * Built with rollup               *
 * Build time: 2024-10-21 14:33:53 *
 * Build mode: production          *
 * Minified: No                    *
 * ***********************************
 */
'use strict';

function inferTypeFromComponent(component) {
  const definition = {
    name: component.name || "UnnamedTemplate",
    props: {},
    emits: {},
    slots: {}
  };
  const componentProps = component.props;
  if (componentProps) {
    if (Array.isArray(componentProps)) {
      componentProps.forEach((prop) => {
        definition.props[prop] = {
          type: "any",
          required: false
        };
      });
    } else {
      Object.entries(componentProps).forEach(([key, value]) => {
        if (typeof value === "function") {
          definition.props[key] = {
            type: value.name.toLowerCase(),
            required: false
          };
        } else if (typeof value === "object" && value !== null) {
          const propDef = value;
          let type = "any";
          if (propDef.type) {
            if (Array.isArray(propDef.type)) {
              type = propDef.type.map((t) => t.name.toLowerCase()).join(" | ");
            } else {
              type = propDef.type.name.toLowerCase();
            }
          }
          definition.props[key] = {
            type,
            required: propDef.required ?? false,
            default: propDef.default,
            description: propDef.description
          };
        }
      });
    }
  }
  const componentEmits = component.emits;
  if (componentEmits) {
    if (Array.isArray(componentEmits)) {
      componentEmits.forEach((emit) => {
        definition.emits[emit] = {
          payload: "any"
        };
      });
    } else {
      Object.entries(componentEmits).forEach(([key, value]) => {
        definition.emits[key] = {
          payload: "any",
          description: typeof value === "object" ? value.description : void 0
        };
      });
    }
  }
  return definition;
}
function generateTypeScriptInterface(definition, options = {}) {
  const {
    includeComments = true
  } = options;
  const lines = [];
  if (includeComments && definition.metadata) {
    lines.push("/**");
    lines.push(` * ${definition.metadata.displayName || definition.name}`);
    if (definition.metadata.description) {
      lines.push(` * ${definition.metadata.description}`);
    }
    lines.push(" */");
  }
  if (definition.props && Object.keys(definition.props).length > 0) {
    lines.push(`export interface ${definition.name}Props {`);
    Object.entries(definition.props).forEach(([key, prop]) => {
      if (includeComments && prop.description) {
        lines.push(`  /** ${prop.description} */`);
      }
      const optional = !prop.required || prop.default !== void 0 ? "?" : "";
      const types = Array.isArray(prop.type) ? prop.type.join(" | ") : prop.type;
      lines.push(`  ${key}${optional}: ${types}`);
    });
    lines.push("}");
    lines.push("");
  }
  if (definition.emits && Object.keys(definition.emits).length > 0) {
    lines.push(`export interface ${definition.name}Emits {`);
    Object.entries(definition.emits).forEach(([key, emit]) => {
      if (includeComments && emit.description) {
        lines.push(`  /** ${emit.description} */`);
      }
      const payload = emit.payload || "void";
      lines.push(`  (e: '${key}', payload: ${payload}): void`);
    });
    lines.push("}");
    lines.push("");
  }
  if (definition.slots && Object.keys(definition.slots).length > 0) {
    lines.push(`export interface ${definition.name}Slots {`);
    Object.entries(definition.slots).forEach(([key, slot]) => {
      if (includeComments && slot.description) {
        lines.push(`  /** ${slot.description} */`);
      }
      if (slot.props && Object.keys(slot.props).length > 0) {
        const slotProps = Object.entries(slot.props).map(([propKey, propType]) => `${propKey}: ${propType}`).join(", ");
        lines.push(`  ${key}(props: { ${slotProps} }): any`);
      } else {
        lines.push(`  ${key}(): any`);
      }
    });
    lines.push("}");
    lines.push("");
  }
  return lines.join("\n");
}
function generateTypeDeclarationFile(definitions, options = {}) {
  const lines = [];
  lines.push("/**");
  lines.push(" * Auto-generated template type definitions");
  lines.push(` * Generated at: ${(/* @__PURE__ */ new Date()).toISOString()}`);
  lines.push(" * Do not edit this file manually");
  lines.push(" */");
  lines.push("");
  lines.push("import type { Component } from 'vue'");
  lines.push("");
  definitions.forEach((definition) => {
    lines.push(generateTypeScriptInterface(definition, options));
  });
  lines.push("/**");
  lines.push(" * Template name to props mapping");
  lines.push(" */");
  lines.push("export interface TemplatePropsMap {");
  definitions.forEach((definition) => {
    if (definition.props && Object.keys(definition.props).length > 0) {
      lines.push(`  '${definition.name}': ${definition.name}Props`);
    }
  });
  lines.push("}");
  lines.push("");
  lines.push("/**");
  lines.push(" * All available template names");
  lines.push(" */");
  const templateNames = definitions.map((d) => `'${d.name}'`).join(" | ");
  lines.push(`export type TemplateNames = ${templateNames}`);
  lines.push("");
  return lines.join("\n");
}
function validateComponentProps(props, definition, strict = true) {
  const errors = [];
  if (!definition.props) {
    return {
      valid: true,
      errors: []
    };
  }
  Object.entries(definition.props).forEach(([key, propDef]) => {
    if (propDef.required && !(key in props)) {
      errors.push(`Missing required prop: ${key}`);
    }
  });
  Object.entries(props).forEach(([key, value]) => {
    const propDef = definition.props[key];
    if (!propDef) {
      if (strict) {
        errors.push(`Unknown prop: ${key}`);
      }
      return;
    }
    const types = Array.isArray(propDef.type) ? propDef.type : [propDef.type];
    const actualType = typeof value;
    const isValidType = types.some((type) => {
      if (type === "any") return true;
      if (type === actualType) return true;
      if (type === "array" && Array.isArray(value)) return true;
      if (type === "object" && value !== null && actualType === "object") return true;
      return false;
    });
    if (!isValidType) {
      errors.push(`Invalid type for prop ${key}: expected ${types.join(" | ")}, got ${actualType}`);
    }
  });
  return {
    valid: errors.length === 0,
    errors
  };
}
function generateTypeGuard(definition) {
  const lines = [];
  lines.push(`export function is${definition.name}Props(props: any): props is ${definition.name}Props {`);
  lines.push("  if (!props || typeof props !== 'object') return false");
  if (definition.props) {
    Object.entries(definition.props).forEach(([key, prop]) => {
      if (prop.required) {
        lines.push(`  if (!('${key}' in props)) return false`);
      }
      const types = Array.isArray(prop.type) ? prop.type : [prop.type];
      const typeChecks = types.map((type) => {
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return `typeof props.${key} === '${type}'`;
          case "array":
            return `Array.isArray(props.${key})`;
          case "object":
            return `typeof props.${key} === 'object' && props.${key} !== null`;
          default:
            return "true";
        }
      });
      if (prop.required) {
        lines.push(`  if (!(${typeChecks.join(" || ")})) return false`);
      } else {
        lines.push(`  if ('${key}' in props && !(${typeChecks.join(" || ")})) return false`);
      }
    });
  }
  lines.push("  return true");
  lines.push("}");
  return lines.join("\n");
}
function generateJSONSchema(definition) {
  const schema = {
    $schema: "http://json-schema.org/draft-07/schema#",
    type: "object",
    title: definition.name,
    properties: {},
    required: []
  };
  if (definition.metadata?.description) {
    schema.description = definition.metadata.description;
  }
  if (definition.props) {
    Object.entries(definition.props).forEach(([key, prop]) => {
      const propSchema = {
        description: prop.description
      };
      const types = Array.isArray(prop.type) ? prop.type : [prop.type];
      if (types.length === 1) {
        propSchema.type = types[0];
      } else {
        propSchema.oneOf = types.map((type) => ({
          type
        }));
      }
      if (prop.default !== void 0) {
        propSchema.default = prop.default;
      }
      schema.properties[key] = propSchema;
      if (prop.required) {
        schema.required.push(key);
      }
    });
  }
  return schema;
}
class TemplateTypeGenerator {
  constructor() {
    this.definitions = /* @__PURE__ */ new Map();
    this.maxDefinitions = 1e3;
  }
  /**
   * 注册模板定义
   */
  register(definition) {
    if (this.definitions.size >= this.maxDefinitions) {
      const firstKey = this.definitions.keys().next().value;
      if (firstKey) {
        this.definitions.delete(firstKey);
      }
    }
    this.definitions.set(definition.name, definition);
  }
  /**
   * 从组件注册
   */
  registerComponent(component) {
    const definition = inferTypeFromComponent(component);
    this.register(definition);
  }
  /**
   * 获取定义
   */
  getDefinition(name) {
    return this.definitions.get(name);
  }
  /**
   * 获取所有定义
   */
  getAllDefinitions() {
    return Array.from(this.definitions.values());
  }
  /**
   * 生成类型文件
   */
  generateTypes(options) {
    return generateTypeDeclarationFile(this.getAllDefinitions(), options);
  }
  /**
   * 生成类型守卫文件
   */
  generateGuards() {
    return this.getAllDefinitions().map((definition) => generateTypeGuard(definition)).join("\n\n");
  }
  /**
   * 生成 JSON Schema
   */
  generateSchemas() {
    const schemas = {};
    this.getAllDefinitions().forEach((definition) => {
      schemas[definition.name] = generateJSONSchema(definition);
    });
    return schemas;
  }
  /**
   * 清除所有定义
   */
  clear() {
    this.definitions.clear();
  }
}
let _typeGenerator = null;
function getTypeGenerator() {
  if (!_typeGenerator) {
    _typeGenerator = new TemplateTypeGenerator();
  }
  return _typeGenerator;
}
function destroyTypeGenerator() {
  if (_typeGenerator) {
    _typeGenerator.clear();
    _typeGenerator = null;
  }
}
let _typeGeneratorProxy = null;
const typeGenerator = new Proxy({}, {
  get(target, prop) {
    if (!_typeGeneratorProxy) {
      _typeGeneratorProxy = getTypeGenerator();
    }
    return _typeGeneratorProxy[prop];
  }
});

exports.TemplateTypeGenerator = TemplateTypeGenerator;
exports.destroyTypeGenerator = destroyTypeGenerator;
exports.generateJSONSchema = generateJSONSchema;
exports.generateTypeDeclarationFile = generateTypeDeclarationFile;
exports.generateTypeGuard = generateTypeGuard;
exports.generateTypeScriptInterface = generateTypeScriptInterface;
exports.getTypeGenerator = getTypeGenerator;
exports.inferTypeFromComponent = inferTypeFromComponent;
exports.typeGenerator = typeGenerator;
exports.validateComponentProps = validateComponentProps;
/*! End of @ldesign/template | Powered by @ldesign/builder */
//# sourceMappingURL=typeGenerator.cjs.map
